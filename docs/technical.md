# Zorsh Schema Generator

## Overview

The schema generator converts Borsh schema definitions into Zorsh type definitions. This is necessary because Borsh and Zorsh use different approaches to represent the same underlying binary format:

1. **Borsh** (Rust-side):

   - Uses Rust's native type system
   - Derives schema information through macros
   - Generates a binary format description (BorshSchemaContainer)

2. **Zorsh** (TypeScript-side):
   - Uses a builder-pattern API
   - Needs explicit schema definitions
   - Must match Borsh's binary format exactly

## Understanding BorshSchemaContainer

A BorshSchemaContainer is Borsh's way of describing a schema as a flat map of type definitions. For example, given this Rust code:

```rust
#[derive(BorshSchema)]
pub struct User {
    name: String,
    age: u8,
    scores: Vec<u32>,
}

#[derive(BorshSchema)]
pub enum Status {
    Active { last_seen: u64 },
    Inactive,
}
```

Borsh generates a schema container like this:

```typescript
{
  // The root type we want to describe
  declaration: "User",

  // A flat map of ALL types involved, including generated ones
  definitions: Map {
    // Original struct definition
    "User" => {
      Struct: {
        fields: {
          NamedFields: [
            { name: "name", declaration: "String" },
            { name: "age", declaration: "u8" },
            { name: "scores", declaration: "Vec<u32>" }
          ]
        }
      }
    },

    // Original enum definition
    "Status" => {
      Enum: {
        tagWidth: 1,
        variants: [
          { discriminant: 0n, name: "Active", declaration: "StatusActive" },
          { discriminant: 1n, name: "Inactive", declaration: "StatusInactive" }
        ]
      }
    },

    // Synthetic type for enum variant
    "StatusActive" => {
      Struct: {
        fields: {
          NamedFields: [
            { name: "last_seen", declaration: "u64" }
          ]
        }
      }
    },

    // Built-in type (String is a length-prefixed sequence of bytes)
    "String" => {
      Sequence: {
        lengthWidth: 4,
        lengthRange: { start: 0n, end: 4294967295n },
        elements: "u8"
      }
    },

    // Generated collection type
    "Vec<u32>" => {
      Sequence: {
        lengthWidth: 4,
        lengthRange: { start: 0n, end: 4294967295n },
        elements: "u32"
      }
    },

    // ... and so on
  }
}
```

### Understanding Synthetic Types

The BorshSchemaContainer includes several categories of types:

1. **Original Types** - Types directly declared in your Rust code:

   ```rust
   struct User { ... }
   enum Status { ... }
   ```

2. **Synthetic Types** - Types generated by Borsh to represent:
   - Collections: `Vec<T>`, `HashMap<K,V>`
   - Options: `Option<T>`
   - Tuples: `(T1, T2)`
   - Enum variants: For variants containing data

Here's how Borsh generates synthetic types for enums:

```rust
// Your Rust enum
enum Status {
    Active { last_seen: u64 },
    Inactive,
}

// Borsh generates these definitions:
"Status" => { // Original enum
  Enum: {
    variants: [
      { name: "Active", declaration: "StatusActive" },
      { name: "Inactive", declaration: "StatusInactive" }
    ]
  }
}

"StatusActive" => { // Generated struct for Active variant
  Struct: {
    fields: {
      NamedFields: [
        { name: "last_seen", declaration: "u64" }
      ]
    }
  }
}

"StatusInactive" => { // Generated empty struct for Inactive variant
  Struct: {
    fields: { Empty: {} }
  }
}
```

3. **Built-in Types** - Primitive types and standard library types:
   - Numbers: `u8`, `i32`, etc.
   - String: Represented as a sequence of bytes

When generating Zorsh schemas, we need to:

1. Identify which types were originally declared vs generated
2. Handle synthetic types appropriately in code generation
3. Maintain the exact same binary format as Borsh

This matters because:

1. We only want to generate top-level Zorsh definitions for original types
2. Synthetic types should be inlined within their parent types
3. The order of type generation affects TypeScript compilation
4. Enum variants need special handling to match Borsh's binary format

## Architecture

The generator is split into several components, each handling a specific part of the transformation pipeline:

### 1. Type Definitions (`types.ts`)

Core type definitions that mirror the Borsh schema structure:

```typescript
type Definition = {
  Primitive?: { size: number };
  Sequence?: {
    lengthWidth: number;
    lengthRange: { start: bigint; end: bigint };
    elements: string;
  };
  Tuple?: { elements: string[] };
  Enum?: {
    tagWidth: number;
    variants: { discriminant: bigint; name: string; declaration: string }[];
  };
  Struct?: {
    fields: {
      NamedFields?: { name: string; declaration: string }[];
      UnnamedFields?: string[];
      Empty?: Record<string, never>;
    };
  };
};

type BorshSchemaContainer = {
  declaration: string;
  definitions: Map<string, Definition>;
};
```

### 2. Schema Analyzer (`analyzer.ts`)

Identifies original type declarations in the Borsh schema, distinguishing them from synthetic types like collections and enum variants.

Key functions:

- Identifies true enum variants vs types used in Option/other enums
- Filters out synthetic types (Vec<T>, HashMap<K,V>, etc.)
- Handles primitive types and built-ins

Example of synthetic vs original types:

```typescript
// Original type
'Stats' => { Struct: { fields: { NamedFields: [...] } } }

// Synthetic type (collection)
'Vec<String>' => { Sequence: { elements: 'String', ... } }

// Synthetic type (enum variant)
'ItemEffectDamage' => { Struct: { fields: { UnnamedFields: ['u32'] } } }
```

### 3. Type Parser (`parser.ts`)

Parses Borsh type expressions into Zorsh schema builder expressions. Uses a declarative approach to define type mappings and handle nested structures.

Key components:

1. **Known Types Definition**:

```typescript
const knownTypes = {
  // Direct mappings for built-in types
  primitives: {
    String: "b.string()",
    "()": "b.unit()",
  },

  // Builder functions for generic types
  generics: {
    Vec: (arg: string) => `b.vec(${arg})`,
    HashMap: (key: string, value: string) => `b.hashMap(${key}, ${value})`,
    HashSet: (arg: string) => `b.hashSet(${arg})`,
    Option: (arg: string) => `b.option(${arg})`,
  },
};
```

2. **Pattern Recognition**:
   The parser identifies three patterns:

- Tuples: `(T1, T2)` → `b.tuple([...])`
- Generics: `Vec<T>` → `b.vec(...)`
- Primitives: Direct types like `String`, `u32`

3. **Example Transformations**:

```typescript
// Primitives
"String" → "b.string()"
"u32" → "b.u32()"

// Generics
"Vec<String>" → "b.vec(b.string())"
"Option<u32>" → "b.option(b.u32())"

// Complex nested types
"HashMap<String, (u16, f32)>" →
  "b.hashMap(b.string(), b.tuple([b.u16(), b.f32()]))"
```

4. **Handling Nested Structures**:

- Uses depth tracking to properly split nested type expressions
- Maintains correct structure for arbitrarily nested generics and tuples
- Preserves type parameter ordering for correct serialization

### 4. Dependency Resolver (`resolver.ts`)

Builds a dependency graph of types and performs topological sorting to ensure types are generated in the correct order.

Process:

1. Builds dependency map from type definitions
2. Handles circular dependencies
3. Returns sorted list of types for generation

### 5. Code Generator (`generator.ts`)

Generates Zorsh schemas from the sorted type definitions.

Features:

- Generates both schema definitions and TypeScript types using b.infer
- Handles struct and enum generation
- Preserves field ordering for correct serialization

## Usage

```typescript
import { ZorshGenerator } from './generator';

const container: BorshSchemaContainer = // ... your Borsh schema
const generator = new ZorshGenerator();
const code = generator.generate(container);
```

## Edge Cases and Considerations

1. **Enum Variants vs Real Types**

   - Types can appear as both standalone types and enum variants
   - We distinguish using context from Option<T> vs real enums

   ```typescript
   // Real enum variant
   'ItemEffectDamage' in ItemEffect.variants
   // Type used in Option
   'Stats' in Option<Stats>.variants
   ```

2. **Dependency Ordering**

   - Types must be defined before they're referenced
   - Circular dependencies are detected and reported
   - Collection types (Vec, HashMap) don't create true dependencies

3. **Type Expression Parsing**
   - Handles arbitrary nesting of generics and tuples
   - Preserves whitespace and formatting
   - Robust against malformed input

## Contributing

When adding features or fixing bugs:

1. **Schema Analysis**

   - Check both synthetic and original type handling
   - Verify enum variant detection
   - Test with new type patterns

2. **Type Parsing**

   - Add test cases for new type patterns
   - Verify AST structure
   - Check generated code matches expected output

3. **Code Generation**

   - Ensure type dependencies are maintained
   - Verify schema and type generation
   - Test serialization/deserialization roundtrip

4. **Testing**
   - Add test cases for new features
   - Include edge cases and error conditions
   - Verify with real-world schemas

## Future Improvements

1. Better error reporting for malformed schemas
2. Support for comments and documentation
3. Schema validation and linting
4. Custom type mappings
5. Optimization of generated code
